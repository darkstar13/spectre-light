#RGB
#first line should be #RGB in order to use rgb renderer, anything else
#will default to the better and slower spectral renderer

#Input file example. The parser is still a temp version, just for debugging
#Misplaced colon or spaces will break everything

#Output file, absolute or relative to the executable
out: /home/user/Desktop/test.ppm

#Resolution width height (width = 2x height suggested with panorama camera)
#width MUST be a multiple of 32
resolution: 800 600

#camera type (pos.x,pos.y,pos.z) (target.x,target.y,target.z) (up.x,up.y,up.z) fov
#type can be perspective, orthographic or panorama
#fov is in degrees and used only with perspective camera
camera: perspective (0,2,-10) (0,0,0) (0,1,0) 55

#sampler type samples per pixel
#type can be random or stratified
sampler: stratified 25

#filter type optional_values
#type can be box, tent, gaussian, mitchell and lanczos
#gaussian requires a sigma parameter, the falloff speed. Suggested a value of 2
#mitchell requires the B and C parameters, suggested values are 0.33 and 0.33
#lanczos requires the tau parameter, the suggested value is 3
filter: mitchell 0.33 0.33

#integrator type
#type can be direct or pt (path trace)
integrator: pt

#material name_without_spaces type optional_values
#types:
#diffuse (r,g,b) roughness
#reflection (r,g,b) material where material is Au, Ag, Al, Cu, Fe, Hg, Pb, Pt or W
#reflection (r,g,b) ior ior where ior is the index of refraction of the incident and transmitted material
#refraction (r,g,b) ior ior where ior is the index of refraction of the incident and transmitted material
#any ior can be in the form [val,val,val] or {val,val,val,val,val,val}
#the first one will use Cauchy equation to determine wavelength-dependent ior, the other will use Sellmeier equation
#if only 1 ior is available use [ior,0,0]. Rgb renderer also expects wavelength dependent iors
#
#glossy reflection_t (r,g,b) metal|ior distribution intensity
#reflection_t is the type of reflection: reflection or refraction
#metal can be Au, Ag...etc. if the material is a conductor, otherwise use ior
#ior is the index of refraction, with cauchy [...] or sellemeier {...} equations like before.
#distirbution can be blinn, beckmann or ggx
#blinn intensity ranges from 0.0 (maximum roughness) to 100000 (maximum specularity)
#beckmann intensity ranges from 0.0(minimum roughness) to 1.0(maximum roughness)
#ggx intensity is like beckmann one, but an optional second parameter can be used for anisotropic reflections
material: Red diffuse (150,0,0) 20
material: Glass reflection (255,255,255) [1,0,0] [1.5046,0.00420,0]
material: Glass refraction (255,255,255) [1.5046,0.00420,0]
material: Gold reflection (255,255,255) Au
material: Brushed_silver glossy (255,255,255) Ag ggx 0.1 0.05
material: Plastic glossy (30,30,255) [1.0,0,0] [1.5,0,0] beckmann 0.1
material: Plastic diffuse (30,30,255) 0

#asset name_without_spaces obj_file_path
#asset name sphere
#asset name box (x_edge_length,y_edge_length,z_edge_length)
#path is absolute or relative to the executable
asset: Ico /home/user/Desktop/test.obj
asset: Big_sphere sphere 100000
asset: Default_sphere sphere 1.0

#light asset_name (pos.x,pos.y,pos.z) (rot.x,rot.y,rot.z) (scale.x,scale.y,scale.z) (r,g,b)
#instead of (r,g,b) it is possible to insert a temperature in Kelvin degrees (6000K = white)
#rotation in sexagesimal degrees
#using asset with high polycount can dramatically increase rendering time
light: Default_sphere (0,2,0) (0,0,0) (1,1,1) 3500K

#world asset_name material_name (pos.x,pos.y,pos.z) (rot.x,rot.y,rot.z) (scale.x,scale.y,scale.z)
#rotation in degrees
world: Big_sphere Red (0,-100001,0) (0,0,0) (1,1,1)
world: Big_sphere Default (-100003,0,0) (0,0,0) (1,1,1)
world: Big_sphere Default (100003,0,0) (0,0,0) (1,1,1)
world: Big_sphere Default (0,0,100005) (0,0,0) (1,1,1)
world: Big_sphere Default (0,100005,0) (0,0,0) (1,1,1)
world: Ico Default (1,-1,0) (0,0,0) (1,1,1)
