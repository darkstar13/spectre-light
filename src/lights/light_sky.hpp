//Created,  15 Oct 2018
//Last Edit  5 Apr 2019

/**
 *  \file light_sky.hpp
 *  \brief     Environment light
 *  \author    Davide Pizzolotto
 *  \version   0.2
 *  \date      5 Apr 2019
 *  \copyright GNU GPLv3
 */


#ifndef __LIGHT_SKY_HPP__
#define __LIGHT_SKY_HPP__

#include "lights/light.hpp"
#include "textures/texture.hpp"
#include "samplers/distributions.hpp"
#include "geometry/matrix4.hpp"

/**
 * \brief Environment light
 *
 * The LightSky class is used to represent a sky and act as a sort of enviroment
 * lighting. The purpose of this class is to represent all the indirect
 * illumination coming from the environment and not actually modeled into the
 * scene.
 */
class LightSky : public Light
{
public:

    /**
     *  \brief Creates the skydome
     *
     *  \param[in] tex The texture that will be used by the dome
     *  \param[in] world_rad The radius of the scene
     */
    LightSky(const Texture* tex, float world_rad);

    /**
     * \brief Default destructor
     */
    ~LightSky() override;

    /**
     * \brief Delete the copy constructor, only one sky should be present
     */
    LightSky(LightSky&) = delete;

    /**
     * \brief UNIMPLEMENTED
     *
     * This method is actually never used in the renderer, so it is left
     * unimplemented
     *
     * \param[in] r0 UNUSED
     * \param[in] r1 UNUSED
     * \param[in] r2 UNUSED
     * \param[in] r3 UNUSED
     * \param[out] out UNUSED
     * \param[out] pdf UNUSED
     * \return black spectrum
     */
    Spectrum sample_surface(float r0, float r1, float r2, float r3, Ray* out,
                            float* pdf) const override;

    /** \brief Generate the incident vector and return the environment radiance
     *
     *  Given a point in the scene, compute the incident direction pointing
     *  towards the sky and compute the radiance arriving at that point.
     *  The point sampled on the sky is randomly chosen on the hemisphere.
     *  This method assume that there are no occluding objects between the light
     *  and the sky
     *
     *  \param[in] r0 A random number in the interval (0.0,1.0)
     *  \param[in] r1 A random number in the interval (0.0,1.0)
     *  \param[in] position UNUSED, the sky surround the entire scene so the
     *  entire hemisphere is used
     *  \param[out] wiW The computed incident direction in world space
     *  \param[out] pdf The probability density function of the chosen point
     *  over the light
     *  \param[out] distance infinity, since the sky is assumed to be
     *  infinitely far away
     *  \return The emitted radiance from the computed ray
     *  \sa sample_surface
     *  \sa pdf(const Point3* p, const Vec3* wi)const
     */
    Spectrum
    sample_visible_surface(float r0, float r1, const Point3* position, Vec3* wi,
                           float* pdf, float* distance) const override;

    /**
     * \brief UNIMPLEMENTED
     *
     * The parent method for this pdf, sample_surface is not implemented, so
     * this is skipped as well
     *
     * \param[in] ray UNUSED
     * \return 0
     */
    float pdf(const Ray* ray) const override;

    /** \brief Return the probability density function for this light
     *
     *  This pdf is correct for rays generated by the sample_visible_surface
     *  method. This is based on the actual texture of the sky and takes into
     *  account the variance reduction techniques used by the
     *  sample_visible_surface function.
     *
     *  \param[in] p UNUSED
     *  \param[in] wiW The incident vector generated with the
     *  sample_visible_surface method and representing the vector pointing
     *  towards the sky, originating from the origin point. In world space.
     *  \return The pdf for this light
     *  \sa sample_visible_surface()
     */
    float pdf(const Point3* p, const Vec3* wiW) const override;

    /**
     * \brief Returns true if the light can be rendered
     *
     * Since this light surrounds the entire scene it is ALWAYS renderable
     * and thus this function returns always true
     *
     * \return true
     */
    bool renderable() const override;

    /**
     *  \brief Returns the radiance of a ray that didn't hit any asset
     *
     *  A sky needs to collect every ray that escapes the scene and return the
     *  correct value for the hit on the skydome. This function, given a ray
     *  that escaped the scene, returns the Spectrum obtained from the skydome
     *  texture.
     *  Note that it is not checked if the ray really escaped the scene.
     *
     *  \param[in] ray The ray that will be used to deterimine the radiance
     *  \return The Spectrum of the radiance for the escaped ray
     */
    Spectrum radiance_escaped(const Ray* ray) const;

    /**
     * \brief No copy allowed
     * \return
     */
    LightSky& operator=(const LightSky&) = delete;

private:
    /** Texture of the sky */
    const Texture* skytexture;
    /**
     * Distribution generated based on the light texture, used for variance
     * reduction
     */
    Distribution2D* distribution;
    /** Matrix used to transform from world space to light space */
    Matrix4 world2light;
    /** Matrix used to transform from light space to world space */
    Matrix4 light2world;
    /** Radius of the scene */
    float world_r;
};

#endif
